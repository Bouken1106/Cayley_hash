import random as rnd
from collections import deque
from sage.all import *  # SageMath environment (matrices, GF, â€¦)
import time
import RandomPrime




def modinv(a, p):
    """
    ãƒ•ã‚§ãƒ«ãƒãƒ¼ã®å°å®šç†ã‚’åˆ©ç”¨ã—ã¦é€†å…ƒã‚’è¨ˆç®—
    returns x such that a * x â‰¡ 1 (mod p)
    """
    return pow(a, p-2, p)


def random_SL2(p):
    """
    å¼•æ•°:
        p (int): ç´ æ•°
    æˆ»ã‚Šå€¤:
        tuple: ((a, b), (c, d)) ã®å½¢å¼ã§ã€è¡Œåˆ—å¼ ad - bc â‰¡ 1 (mod p) ã‚’æº€ãŸã™ãƒ©ãƒ³ãƒ€ãƒ ãªè¡Œåˆ—

    ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ :
    1. (a, b) ã‚’ F_p^2 \ {(0,0)} ã‹ã‚‰ä¸€æ§˜ã«é¸ã¶
    2. a != 0 ã®å ´åˆ:
         - c ã‚’ F_p ã‹ã‚‰ä¸€æ§˜ã«é¸ã¶
         - d = (1 + b*c) * a^{-1} mod p ã§è¨ˆç®—
    3. a == 0 (ã‹ã¤ b != 0) ã®å ´åˆ:
         - c = -b^{-1} mod p ã§ä¸€æ„ã«æ±ºå®š
         - d ã‚’ F_p ã‹ã‚‰ä¸€æ§˜ã«é¸ã¶
    æ‹’å¦ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ä¸è¦ã® O(1) ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
    """
    # 1. (a, b) ã‚’é¸æŠ
    while True:
        a = rnd.randrange(p)
        b = rnd.randrange(p)
        if a != 0 or b != 0:
            break

    # 2. (c, d) ã‚’æ¡ä»¶ä»˜ãã§æ±ºå®š
    if a != 0:
        inv_a = modinv(a, p)
        c = rnd.randrange(p)
        d = (inv_a * (1 + b * c)) % p
    else:
        # a == 0 ã®å ´åˆ b != 0
        inv_b = modinv(b, p)
        c = (-inv_b) % p
        d = rnd.randrange(p)

    return ((a, b), (c, d))

def to_sage_matrix(M_tuple, p):
    """
    2Ã—2 ã®ã‚¿ãƒ—ãƒ« ((a, b), (c, d)) ã‚’ SageMath ã® GF(p) ä¸Šã® Matrix å‹ã«å¤‰æ›

    å¼•æ•°:
        M_tuple (tuple): ((a, b), (c, d)) ã®è¡Œåˆ—ãƒ‡ãƒ¼ã‚¿
        p (int): ç´ æ•°
    æˆ»ã‚Šå€¤:
        sage.matrix.matrix2dense.Matrix2Dense: GF(p) ä¸Šã® 2x2 è¡Œåˆ—
    """
    mat_list = [[M_tuple[0][0], M_tuple[0][1]], [M_tuple[1][0], M_tuple[1][1]]]
    return Matrix(GF(p), mat_list)

def _mat_key(M):
    """Return a hashable key for a Sage matrix (tuple of its entries)."""
    return tuple(M.list())  # rowâ€‘major order

def shortest_word_in_A_B(M, p):
    """Return the shortest A/B word representing *M* âˆˆ SLâ‚‚(ğ”½â‚š).

    Parameters
    ----------
    M : 2Ã—2 Sage matrix over GF(p) with det(M) == 1
    p : prime (int)

    Returns
    -------
    str
        A string such as "ABA" whose product equals *M*.
    """
    F = GF(p)
    A = matrix(F, [[1, 1], [0, 1]])
    B = matrix(F, [[1, 0], [1, 1]])
    gens = {'A': A, 'B': B}

    I = matrix(F, 2, 2, [1, 0, 0, 1])
    if M == I:
        return ""  # identity = empty word

    target_key = _mat_key(M)

    # BFS across the Cayley graph generated by A, B
    visited = {_mat_key(I)}
    queue = deque([(I, "")])

    while queue:
        current, word = queue.popleft()
        for name, g in gens.items():
            nxt = current * g  # right multiplication â†’ word read leftâ†’right
            nxt_key = _mat_key(nxt)
            if nxt_key == target_key:
                return word + name
            if nxt_key not in visited:
                visited.add(nxt_key)
                queue.append((nxt, word + name))

    # If no decomposition was found (possible for p = 2)
    raise ValueError("Matrix not reachable with generators A, B. Ensure p â‰¥ 3 and det(M)=1.")

# ---------------------------------------------------------------------------
# demo / commandâ€‘line interface
# ---------------------------------------------------------------------------

def _demo():
    """Run a tiny selfâ€‘test for p = 3."""
    p = 3
    F = GF(p)
    M = matrix(F, [[2, 0], [1, 2]])  # Expected: ABA
    word = shortest_word_in_A_B(M, p)
    print(f"Shortest word for {M} over F_{p}: {word}")

if __name__ == "__main__":
    _demo()


p = 13
M = to_sage_matrix(random_SL2(p),p)
print(M)
x = []
for j in range(7):
    t = 0
    for i in range(1):
        p = RandomPrime.random_n_bit_prime(j + 1)
        print(p)
        M = to_sage_matrix(random_SL2(p),p)
        start = time.time()
        word = shortest_word_in_A_B(M, p)
        end = time.time()
        t = t + end - start
    x.append(t/1)

# -*- coding: utf-8 -*-
import matplotlib.pyplot as plt

# ä¸ãˆã‚‰ã‚ŒãŸãƒªã‚¹ãƒˆ x ã«å¯¾ã—ã¦ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ i ã‚’ "i ãƒ“ãƒƒãƒˆ" ã¨ã—ã€
# å„è¦ç´  x[i] ã‚’ "x[i] ç§’" ã¨ã—ã¦ãƒ—ãƒ­ãƒƒãƒˆã™ã‚‹é–¢æ•°

def plot_i_bit_vs_seconds(x):
    # ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ãƒªã‚¹ãƒˆã‚’ä½œæˆï¼ˆ0 ã‹ã‚‰ len(x)-1ï¼‰
    indices = list(range(len(x)))

    # ãƒ—ãƒ­ãƒƒãƒˆã‚’ä½œæˆ
    plt.figure(figsize=(8, 5))  # å›³ã®ã‚µã‚¤ã‚ºã‚’æŒ‡å®š
    plt.plot(indices, x, marker='o', linestyle='-')  # ãƒãƒ¼ã‚«ãƒ¼ä»˜ãã®æŠ˜ã‚Œç·šã‚°ãƒ©ãƒ•

    # x è»¸ã®ç›®ç››ã‚Šã‚’ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã«åˆã‚ã›ã‚‹
    plt.xticks(indices)

    # ã‚°ãƒªãƒƒãƒ‰ã‚’è¡¨ç¤º
    plt.grid(True)

    # ãƒ—ãƒ­ãƒƒãƒˆã‚’è¡¨ç¤º
    plt.show()


if __name__ == '__main__':
    # ãƒ†ã‚¹ãƒˆç”¨ã®ãƒªã‚¹ãƒˆä¾‹
    plot_i_bit_vs_seconds(x)


print(f"Shortest word for {M} over F_{p}: {word}")
print(x)