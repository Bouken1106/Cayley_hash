import random as rnd
from collections import deque
from sage.all import *  # SageMath environment (matrices, GF, …)
import time
import RandomPrime




def modinv(a, p):
    """
    フェルマーの小定理を利用して逆元を計算
    returns x such that a * x ≡ 1 (mod p)
    """
    return pow(a, p-2, p)


def random_SL2(p):
    """
    引数:
        p (int): 素数
    戻り値:
        tuple: ((a, b), (c, d)) の形式で、行列式 ad - bc ≡ 1 (mod p) を満たすランダムな行列

    アルゴリズム:
    1. (a, b) を F_p^2 \ {(0,0)} から一様に選ぶ
    2. a != 0 の場合:
         - c を F_p から一様に選ぶ
         - d = (1 + b*c) * a^{-1} mod p で計算
    3. a == 0 (かつ b != 0) の場合:
         - c = -b^{-1} mod p で一意に決定
         - d を F_p から一様に選ぶ
    拒否サンプリング不要の O(1) アルゴリズム
    """
    # 1. (a, b) を選択
    while True:
        a = rnd.randrange(p)
        b = rnd.randrange(p)
        if a != 0 or b != 0:
            break

    # 2. (c, d) を条件付きで決定
    if a != 0:
        inv_a = modinv(a, p)
        c = rnd.randrange(p)
        d = (inv_a * (1 + b * c)) % p
    else:
        # a == 0 の場合 b != 0
        inv_b = modinv(b, p)
        c = (-inv_b) % p
        d = rnd.randrange(p)

    return ((a, b), (c, d))

def to_sage_matrix(M_tuple, p):
    """
    2×2 のタプル ((a, b), (c, d)) を SageMath の GF(p) 上の Matrix 型に変換

    引数:
        M_tuple (tuple): ((a, b), (c, d)) の行列データ
        p (int): 素数
    戻り値:
        sage.matrix.matrix2dense.Matrix2Dense: GF(p) 上の 2x2 行列
    """
    mat_list = [[M_tuple[0][0], M_tuple[0][1]], [M_tuple[1][0], M_tuple[1][1]]]
    return Matrix(GF(p), mat_list)

def _mat_key(M):
    """Return a hashable key for a Sage matrix (tuple of its entries)."""
    return tuple(M.list())  # row‑major order

def shortest_word_in_A_B(M, p):
    """Return the shortest A/B word representing *M* ∈ SL₂(𝔽ₚ).

    Parameters
    ----------
    M : 2×2 Sage matrix over GF(p) with det(M) == 1
    p : prime (int)

    Returns
    -------
    str
        A string such as "ABA" whose product equals *M*.
    """
    F = GF(p)
    A = matrix(F, [[1, 1], [0, 1]])
    B = matrix(F, [[1, 0], [1, 1]])
    gens = {'A': A, 'B': B}

    I = matrix(F, 2, 2, [1, 0, 0, 1])
    if M == I:
        return ""  # identity = empty word

    target_key = _mat_key(M)

    # BFS across the Cayley graph generated by A, B
    visited = {_mat_key(I)}
    queue = deque([(I, "")])

    while queue:
        current, word = queue.popleft()
        for name, g in gens.items():
            nxt = current * g  # right multiplication → word read left→right
            nxt_key = _mat_key(nxt)
            if nxt_key == target_key:
                return word + name
            if nxt_key not in visited:
                visited.add(nxt_key)
                queue.append((nxt, word + name))

    # If no decomposition was found (possible for p = 2)
    raise ValueError("Matrix not reachable with generators A, B. Ensure p ≥ 3 and det(M)=1.")

# ---------------------------------------------------------------------------
# demo / command‑line interface
# ---------------------------------------------------------------------------

def _demo():
    """Run a tiny self‑test for p = 3."""
    p = 3
    F = GF(p)
    M = matrix(F, [[2, 0], [1, 2]])  # Expected: ABA
    word = shortest_word_in_A_B(M, p)
    print(f"Shortest word for {M} over F_{p}: {word}")

if __name__ == "__main__":
    _demo()


p = 13
M = to_sage_matrix(random_SL2(p),p)
print(M)
x = []
for j in range(7):
    t = 0
    for i in range(1):
        p = RandomPrime.random_n_bit_prime(j + 1)
        print(p)
        M = to_sage_matrix(random_SL2(p),p)
        start = time.time()
        word = shortest_word_in_A_B(M, p)
        end = time.time()
        t = t + end - start
    x.append(t/1)

# -*- coding: utf-8 -*-
import matplotlib.pyplot as plt

# 与えられたリスト x に対して、インデックス i を "i ビット" とし、
# 各要素 x[i] を "x[i] 秒" としてプロットする関数

def plot_i_bit_vs_seconds(x):
    # インデックスのリストを作成（0 から len(x)-1）
    indices = list(range(len(x)))

    # プロットを作成
    plt.figure(figsize=(8, 5))  # 図のサイズを指定
    plt.plot(indices, x, marker='o', linestyle='-')  # マーカー付きの折れ線グラフ

    # x 軸の目盛りをインデックスに合わせる
    plt.xticks(indices)

    # グリッドを表示
    plt.grid(True)

    # プロットを表示
    plt.show()


if __name__ == '__main__':
    # テスト用のリスト例
    plot_i_bit_vs_seconds(x)


print(f"Shortest word for {M} over F_{p}: {word}")
print(x)